/*
 * per-CPU timer vector definitions:
 */
#define TVN_BITS (CONFIG_BASE_SMALL ? 4 : 6)
#define TVR_BITS (CONFIG_BASE_SMALL ? 6 : 8)
#define TVN_SIZE (1 << TVN_BITS)
#define TVR_SIZE (1 << TVR_BITS)
#define TVN_MASK (TVN_SIZE - 1)
#define TVR_MASK (TVR_SIZE - 1)

//TVR_SIZE = 1 << 8 = 256
//TVN_SIZE = 1 << 6 = 64

struct tvec {
	struct list_head vec[TVN_SIZE];
};
struct tvec_root {
	struct list_head vec[TVR_SIZE];
};
struct tvec_base {
	spinlock_t lock;
	struct timer_list *running_timer;
	unsigned long timer_jiffies;
	unsigned long next_timer;
	struct tvec_root tv1;
	struct tvec tv2;
	struct tvec tv3;
	struct tvec tv4;
	struct tvec tv5;
} ____cacheline_aligned;
struct tvec_base boot_tvec_bases;
EXPORT_SYMBOL(boot_tvec_bases);
static DEFINE_PER_CPU(struct tvec_base *, tvec_bases) = &boot_tvec_bases;


struct timer_list {
	struct list_head entry;
	unsigned long expires;
	struct tvec_base *base;
	void (*function)(unsigned long);
	unsigned long data;
};

static inline int timer_pending(const struct timer_list * timer)
{
	return timer->entry.next != NULL;
}
=========================================================================================================
ğŸ”¹ What is detach_timer()?
When a timer in Linux is expired or re-queued, it needs to be detached from the hash bucket list (tv1..tv5).
Thatâ€™s what detach_timer() does: it unlinks the timer safely from whatever list it is in.
==========================================================================================================
static inline void detach_timer(struct timer_list *timer, int clear_pending)
{
    if (timer_pending(timer)) {
        list_del(&timer->entry);
        if (clear_pending)
            timer->entry.next = NULL;
    }
}

int mod_timer(struct timer_list *timer, unsigned long expires)
{
  	return __mod_timer(timer, expires, false, TIMER_NOT_PINNED);
}

static inline int __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only, int pinned)
{
    	base = lock_timer_base(timer, &flags);
	   if (timer_pending(timer)) {
		        detach_timer(timer, 0);
		        if (timer->expires == base->next_timer)
			        base->next_timer = base->timer_jiffies;
		          ret = 1;
	  } 
	timer->expires = expires;
	if (time_before(timer->expires, base->next_timer))
      		base->next_timer = timer->expires;
	internal_add_timer(base, timer);
}

static void internal_add_timer(struct tvec_base *base, struct timer_list *timer)
{
    unsigned long expires = timer->expires;
    unsigned long idx = expires - base->timer_jiffies;
    struct list_head *vec;

    if (idx < TVR_SIZE) {
        // Near expiry â†’ put into tv1
        int i = expires & TVR_MASK;
        vec = base->tv1.vec + i;
    } else if (idx < 1 << (TVR_BITS + TVN_BITS)) {
        // Goes into tv2
        int i = (expires >> TVR_BITS) & TVN_MASK;
        vec = base->tv2.vec + i;
    } else if (idx < 1 << (TVR_BITS + 2*TVN_BITS)) {
        // Goes into tv3
        int i = (expires >> (TVR_BITS + TVN_BITS)) & TVN_MASK;
        vec = base->tv3.vec + i;
    } else if (idx < 1 << (TVR_BITS + 3*TVN_BITS)) {
        // Goes into tv4
        int i = (expires >> (TVR_BITS + 2*TVN_BITS)) & TVN_MASK;
        vec = base->tv4.vec + i;
    } else if ((long)idx < 0) {
        // Already expired â†’ run soon
        vec = base->tv1.vec + (base->timer_jiffies & TVR_MASK);
    } else {
        // Far future â†’ goes into tv5
        int i = (expires >> (TVR_BITS + 4*TVN_BITS)) & TVN_MASK;
        vec = base->tv5.vec + i;
    }

    // Link timer into chosen bucket
    list_add_tail(&timer->entry, vec);
}
==================================================================================
2. Whatâ€™s happening?
base->timer_jiffies = the "current time" in the timer wheel for this CPU.
timer->expires = the absolute expiry time (in jiffies).

idx = expires - timer_jiffies = how far in the future the timer is.

Then:
If itâ€™s very near (fits in tv1 slots), it goes to tv1. Otherwise it goes to tv2, tv3, â€¦ up to tv5.
The exact bucket index is chosen using bit shifts & masks.

3. Example Walkthrough
Setup

Assume:
TVR_BITS = 8 â†’ 256 slots in tv1
TVN_BITS = 6 â†’ 64 slots in tv2â€“tv5

Current base->timer_jiffies = 1000

Step-by-step
1. Timer with expires=1005
idx = 1005-1000=5 (<256) â†’ goes to tv1.
Slot = 1005 & 0xFF = 229.
Stored in tv1.vec[229].
2. Timer with expires=1100
idx = 100.
100 < 256 â†’ goes to tv1.
Slot = 1100 & 0xFF = 76.
Stored in tv1.vec[76].
3. Timer with expires=1200
idx = 200.
200 < 256 â†’ tv1.
Slot = 1200 & 0xFF = 176.
Stored in tv1.vec[176].

4. Timer with expires=2000
idx = 1000.
1000 >= 256, but 1000 < (1 << (8+6)) = 16384 â†’ goes to tv2.
Slot = (2000 >> 8) & 63 = 7.
Stored in tv2.vec[7].
5. Timer with expires=5000
idx = 4000.
Still <16384 â†’ tv2.
Slot = (5000 >> 8) & 63 = 19.
Stored in tv2.vec[19].
6. Timer with expires=100000
idx = 99000.
Too large for tv2 (<16384) but <1 << (8+2*6) = 1,048,576 â†’ goes to tv3.
Slot = (100000 >> (8+6)) & 63 = 24.
Stored in tv3.vec[24].

Diagram (simplified)
 tv1 (256 slots)                  tv2 (64 slots)             tv3 (64 slots)
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”
 â”‚ vec[76]  â†’ Timer(exp=1100)     â”‚ vec[7]  â†’ Timer(2000)    â”‚ vec[24] â†’ Timer(100000)
 â”‚ vec[176] â†’ Timer(exp=1200)     â”‚ vec[19] â†’ Timer(5000)    â”‚
 â”‚ vec[229] â†’ Timer(exp=1005)     â”‚                          â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”˜                        â””â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”˜

