#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define HASH_SIZE 100

// Linked list node structure
typedef struct ListNode {
    int data;
    struct ListNode* next;
} ListNode;

// Hash table node structure
typedef struct HashNode {
    int key;
    struct HashNode* next;
} HashNode;

// Hash table structure
typedef struct {
    HashNode* buckets[HASH_SIZE];
} HashMap;

// Hash function
int hash(int key) {
    return abs(key) % HASH_SIZE;
}

// Initialize hash map
void initHashMap(HashMap* map) {
    for (int i = 0; i < HASH_SIZE; i++) {
        map->buckets[i] = NULL;
    }
}

// Check if key exists in hash map
bool contains(HashMap* map, int key) {
    int index = hash(key);
    HashNode* current = map->buckets[index];
    
    while (current != NULL) {
        if (current->key == key) {
            return true;
        }
        current = current->next;
    }
    return false;
}

// Insert key into hash map
void insert(HashMap* map, int key) {
    if (contains(map, key)) {
        return; // Key already exists
    }
    
    int index = hash(key);
    HashNode* newNode = (HashNode*)malloc(sizeof(HashNode));
    newNode->key = key;
    newNode->next = map->buckets[index];
    map->buckets[index] = newNode;
}

// Free hash map memory
void freeHashMap(HashMap* map) {
    for (int i = 0; i < HASH_SIZE; i++) {
        HashNode* current = map->buckets[i];
        while (current != NULL) {
            HashNode* temp = current;
            current = current->next;
            free(temp);
        }
        map->buckets[i] = NULL;
    }
}

// Create a new list node
ListNode* createNode(int data) {
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Insert at the beginning of linked list
void insertAtHead(ListNode** head, int data) {
    ListNode* newNode = createNode(data);
    newNode->next = *head;
    *head = newNode;
}

// Insert at the end of linked list
void insertAtTail(ListNode** head, int data) {
    ListNode* newNode = createNode(data);
    
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    
    ListNode* current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = newNode;
}

// Remove duplicates from linked list using hashmap
void removeDuplicates(ListNode** head) {
    if (*head == NULL) {
        return;
    }
    
    HashMap map;
    initHashMap(&map);
    
    ListNode* current = *head;
    ListNode* prev = NULL;
    
    while (current != NULL) {
        if (contains(&map, current->data)) {
            // Duplicate found, remove current node
            prev->next = current->next;
            free(current);
            current = prev->next;
        } else {
            // First occurrence, add to hashmap
            insert(&map, current->data);
            prev = current;
            current = current->next;
        }
    }
    
    freeHashMap(&map);
}

// Alternative approach: Create new list without duplicates
ListNode* removeDuplicatesNewList(ListNode* head) {
    if (head == NULL) {
        return NULL;
    }
    
    HashMap map;
    initHashMap(&map);
    
    ListNode* newHead = NULL;
    ListNode* current = head;
    
    while (current != NULL) {
        if (!contains(&map, current->data)) {
            // First occurrence, add to new list and hashmap
            insert(&map, current->data);
            insertAtTail(&newHead, current->data);
        }
        current = current->next;
    }
    
    freeHashMap(&map);
    return newHead;
}

// Print linked list
void printList(ListNode* head) {
    ListNode* current = head;
    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }
    printf("\n");
}

// Free linked list memory
void freeList(ListNode* head) {
    ListNode* current = head;
    while (current != NULL) {
        ListNode* temp = current;
        current = current->next;
        free(temp);
    }
}

// Count nodes in linked list
int countNodes(ListNode* head) {
    int count = 0;
    ListNode* current = head;
    while (current != NULL) {
        count++;
        current = current->next;
    }
    return count;
}

int main() {
    // Test 1: In-place removal
    printf("=== Test 1: In-place duplicate removal ===\n");
    ListNode* list1 = NULL;
    
    // Create list: 4 -> 2 -> 5 -> 4 -> 3 -> 2 -> 8 -> 3 -> 1 -> 5
    int data1[] = {4, 2, 5, 4, 3, 2, 8, 3, 1, 5};
    int n1 = sizeof(data1) / sizeof(data1[0]);
    
    for (int i = 0; i < n1; i++) {
        insertAtTail(&list1, data1[i]);
    }
    
    printf("Original list: ");
    printList(list1);
    printf("Original count: %d\n", countNodes(list1));
    
    removeDuplicates(&list1);
    
    printf("After removing duplicates: ");
    printList(list1);
    printf("New count: %d\n", countNodes(list1));
    
    freeList(list1);
    
    // Test 2: Create new list approach
    printf("\n=== Test 2: Create new list approach ===\n");
    ListNode* list2 = NULL;
    
    // Create list: 1 -> 2 -> 1 -> 3 -> 2 -> 4 -> 3 -> 5
    int data2[] = {1, 2, 1, 3, 2, 4, 3, 5};
    int n2 = sizeof(data2) / sizeof(data2[0]);
    
    for (int i = 0; i < n2; i++) {
        insertAtTail(&list2, data2[i]);
    }
    
    printf("Original list: ");
    printList(list2);
    printf("Original count: %d\n", countNodes(list2));
    
    ListNode* newList = removeDuplicatesNewList(list2);
    
    printf("New list without duplicates: ");
    printList(newList);
    printf("New count: %d\n", countNodes(newList));
    
    freeList(list2);
    freeList(newList);
    
    // Test 3: Edge cases
    printf("\n=== Test 3: Edge cases ===\n");
    
    // Empty list
    ListNode* emptyList = NULL;
    printf("Empty list test:\n");
    removeDuplicates(&emptyList);
    printf("After removal: ");
    printList(emptyList);
    
    // Single element
    ListNode* singleList = createNode(42);
    printf("Single element test: ");
    printList(singleList);
    removeDuplicates(&singleList);
    printf("After removal: ");
    printList(singleList);
    freeList(singleList);
    
    // All duplicates
    ListNode* dupList = NULL;
    for (int i = 0; i < 5; i++) {
        insertAtTail(&dupList, 7);
    }
    printf("All duplicates test: ");
    printList(dupList);
    removeDuplicates(&dupList);
    printf("After removal: ");
    printList(dupList);
    freeList(dupList);
    
    return 0;
}


=============================================================================================================================
The `insert` function in the provided C program adds a key to a hash map, which is used to track unique values during the removal of duplicates from an unsorted linked list. Below, I’ll explain the function in detail, including its purpose, how it works, its role in the program, and provide an example with a diagram to illustrate the process.

### Code Explanation
Here’s the `insert` function with detailed comments:

void insert(HashMap* map, int key) {
    if (contains(map, key)) { // Check if key already exists in hash map
        return; // Key already exists, no insertion needed
    }
    
    int index = hash(key); // Compute hash index for the key
    HashNode* newNode = (HashNode*)malloc(sizeof(HashNode)); // Allocate new hash node
    newNode->key = key; // Set the key
    newNode->next = map->buckets[index]; // Link to existing bucket list
    map->buckets[index] = newNode; // Update bucket to point to new node
}
```

#### Key Components
- **HashMap Structure**:
  ```c
  typedef struct {
      HashNode* buckets[HASH_SIZE];
  } HashMap;
  ```
  - `buckets`: An array of `HashNode*` pointers, where `HASH_SIZE=1000`. Each bucket can hold a linked list of `HashNode`s to handle collisions.
- **HashNode Structure**:
  ```c
  typedef struct HashNode {
      int key;
      struct HashNode* next;
  } HashNode;
  ```
  - `key`: The value to store (from the linked list).
  - `next`: Pointer to the next `HashNode` in the same bucket (for collision handling).
- **Related Functions**:
  - `contains`: Checks if a key exists in the hash map.
  - `hash`: Computes the bucket index for a key (`abs(key) % HASH_SIZE`).
- **Purpose**: Adds a new key to the hash map if it doesn’t already exist, ensuring only unique keys are stored.

#### How It Works
1. **Check for Existence**:
   - Calls `contains(map, key)` to check if the key is already in the hash map.
   - If the key exists, the function returns immediately to avoid duplicates (critical for the duplicate removal logic).
2. **Compute Index**:
   - Uses `hash(key)` to map the key to a bucket index (0 to `HASH_SIZE-1`).
3. **Create New Node**:
   - Allocates a new `HashNode` using `malloc`.
   - Sets `newNode->key = key` to store the value.
4. **Insert into Bucket**:
   - Sets `newNode->next = map->buckets[index]`, linking the new node to the existing linked list in the bucket (or `NULL` if the bucket is empty).
   - Updates `map->buckets[index] = newNode`, making the new node the head of the bucket’s linked list.
5. **Effect**: The key is added to the hash map in O(1) average time, with chaining to handle collisions.

#### Role in the Program
The `insert` function is used in the `removeDuplicates` and `removeDuplicatesNewList` functions to track unique values from the linked list:
- In `removeDuplicates`, it adds a node’s `data` to the hash map if it’s not already present, ensuring only the first occurrence of each value is kept.
- In `removeDuplicatesNewList`, it adds values to the hash map and builds a new list with unique values.

### Example Walkthrough
Let’s walk through the `insert` function with a sample linked list: `4 -> 2 -> 5 -> 4`. The hash map is used to track unique values, and we’ll insert the 
values `4`, `2`, `5`, and attempt to insert `4` again.

**Initial State**:
- Hash map after `initHashMap`:
  ```
  HashMap:
  +---------------------------+
  | buckets:                  |
  | [0] ----> NULL            |
  | [1] ----> NULL            |
  | [2] ----> NULL            |
  | ...                       |
  | [999] --> NULL            |
  +---------------------------+
  ```
- Assume `hash(4)=4`, `hash(2)=2`, `hash(5)=5` for simplicity.

**Step 1: Insert `4`**:
- Call: `insert(&map, 4)`
- `contains(&map, 4)`: Returns `false` (bucket 4 is `NULL`).
- `index = hash(4) = 4`.
- Create `newNode`: `key=4`, `next=NULL`.
- `newNode->next = map->buckets[4] (NULL)`.
- `map->buckets[4] = newNode`.
- **Hash Map**:
  ```
  HashMap:
  +---------------------------+
  | buckets:                  |
  | [0] ----> NULL            |
  | [1] ----> NULL            |
  | [2] ----> NULL            |
  | [3] ----> NULL            |
  | [4] ----> [HashNode: key=4, next=NULL] |
  | ...                       |
  | [999] --> NULL            |
  +---------------------------+
  ```

**Step 2: Insert `2`**:
- Call: `insert(&map, 2)`
- `contains(&map, 2)`: Returns `false`.
- `index = hash(2) = 2`.
- Create `newNode`: `key=2`, `next=NULL`.
- `newNode->next = map->buckets[2] (NULL)`.
- `map->buckets[2] = newNode`.
- **Hash Map**:
  ```
  HashMap:
  +---------------------------+
  | buckets:                  |
  | [0] ----> NULL            |
  | [1] ----> NULL            |
  | [2] ----> [HashNode: key=2, next=NULL] |
  | [3] ----> NULL            |
  | [4] ----> [HashNode: key=4, next=NULL] |
  | ...                       |
  | [999] --> NULL            |
  +---------------------------+
  ```

**Step 3: Insert `5`**:
- Call: `insert(&map, 5)`
- `contains(&map, 5)`: Returns `false`.
- `index = hash(5) = 5`.
- Create `newNode`: `key=5`, `next=NULL`.
- `newNode->next = map->buckets[5] (NULL)`.
- `map->buckets[5] = newNode`.
- **Hash Map**:
  ```
  HashMap:
  +---------------------------+
  | buckets:                  |
  | [0] ----> NULL            |
  | [1] ----> NULL            |
  | [2] ----> [HashNode: key=2, next=NULL] |
  | [3] ----> NULL            |
  | [4] ----> [HashNode: key=4, next=NULL] |
  | [5] ----> [HashNode: key=5, next=NULL] |
  | ...                       |
  | [999] --> NULL            |
  +---------------------------+
  ```

**Step 4: Attempt to Insert `4`**:
- Call: `insert(&map, 4)`
- `contains(&map, 4)`: Returns `true` (found in `buckets[4]`).
- Function returns immediately, no insertion occurs.
- **Hash Map**: Unchanged.

**Step 5: Insert `104` (Collision Example)**:
- Assume `hash(104) = 4` (e.g., `abs(104) % 1000 = 4`).
- Call: `insert(&map, 104)`
- `contains(&map, 104)`: Returns `false` (no `key=104` in `buckets[4]`).
- `index = hash(104) = 4`.
- Create `newNode`: `key=104`, `next=map->buckets[4]` (points to `HashNode: key=4`).
- `map->buckets[4] = newNode`.
- **Hash Map**:
  ```
  HashMap:
  +---------------------------+
  | buckets:                  |
  | [0] ----> NULL            |
  | [1] ----> NULL            |
  | [2] ----> [HashNode: key=2, next=NULL] |
  | [3] ----> NULL            |
  | [4] ----> [HashNode: key=104, next] --> [HashNode: key=4, next=NULL] |
  | [5] ----> [HashNode: key=5, next=NULL] |
  | ...                       |
  | [999] --> NULL            |
  +---------------------------+
  ```

### Diagram
#### Initial Hash Map (after `initHashMap`):
```
HashMap:
+---------------------------+
| buckets:                  |
| [0] ----> NULL            |
| [1] ----> NULL            |
| [2] ----> NULL            |
| [3] ----> NULL            |
| [4] ----> NULL            |
| [5] ----> NULL            |
| ...                       |
| [999] --> NULL            |
+---------------------------+
```

#### After Inserting `4`, `2`, `5`:
```
HashMap:
+---------------------------+
| buckets:                  |
| [0] ----> NULL            |
| [1] ----> NULL            |
| [2] ----> [HashNode: key=2, next=NULL] |
| [3] ----> NULL            |
| [4] ----> [HashNode: key=4, next=NULL] |
| [5] ----> [HashNode: key=5, next=NULL] |
| ...                       |
| [999] --> NULL            |
+---------------------------+
```

#### After Inserting `104` (Collision at `hash(104)=4`):
```
HashMap:
+---------------------------+
| buckets:                  |
| [0] ----> NULL            |
| [1] ----> NULL            |
| [2] ----> [HashNode: key=2, next=NULL] |
| [3] ----> NULL            |
| [4] ----> [HashNode: key=104, next] --> [HashNode: key=4, next=NULL] |
| [5] ----> [HashNode: key=5, next=NULL] |
| ...                       |
| [999] --> NULL            |
+---------------------------+
```

### Role in Duplicate Removal
- **Context**: The `insert` function is called in `removeDuplicates` and `removeDuplicatesNewList` to add a linked list node’s `data` to the hash map when it’s encountered
for the first time.
- **Example**: For the list `4 -> 2 -> 5 -> 4`:
  - `insert(&map, 4)`: Adds `4` to `buckets[4]`.
  - `insert(&map, 2)`: Adds `2` to `buckets[2]`.
  - `insert(&map, 5)`: Adds `5` to `buckets[5]`.
  - Second `4`: `contains(&map, 4)` returns `true`, so `insert` returns without action, and the node is removed.
- **Purpose**: Ensures only the first occurrence of each value is kept by tracking seen values in the hash map.

### Key Points
- **Purpose**: Adds a key to the hash map if it doesn’t exist, using chaining for collisions.
- **Efficiency**: O(1) average-case time for insertion (assuming good hash distribution).
- **Collision Handling**: Inserts at the head of the bucket’s linked list, supporting multiple keys per bucket.
- **Role**: Tracks unique values to identify duplicates in the linked list.
- **ARM Compatibility**: Standard C, runs on ARM or any architecture.

The `insert` function is critical for efficiently building the hash map, enabling O(n) duplicate removal by ensuring only unique keys are stored and collisions are
handled via linked lists. The diagram illustrates how the hash map evolves with each insertion.
