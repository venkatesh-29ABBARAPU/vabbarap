The FIFO size is 4096 bytes the register is at address 0x8000. In that register
byte 1 has the register is 0: rx fifo empty, 1: rx fifo full , 4: tx fifo empty, 6: tx fifo full
byte 2 is reserved
byte 3 is fifo window where we can read a byte if the data is valid and if there is no data if it will return garbage value?
could you please implement drain_rx_fifo(uint8_t *dest_buffer, int buffer_size) 
-------------------------------------------------------------------------------------------------------------
FIFO depth = 4096 bytes, but we only read one byte per access from byte3.
If FIFO is empty and we still read byte3 → it returns garbage → so we must check the empty flag first before reading.
======================================================================================
#include <stdint.h>
#include <stdio.h>

// Register base address
#define FIFO_REG_ADDR   0x8000
#define FIFO_REG        (*(volatile uint32_t *)(FIFO_REG_ADDR))

// Status bit masks (Byte0)
#define RX_FIFO_EMPTY   0x01
#define RX_FIFO_FULL    0x02
#define TX_FIFO_EMPTY   0x04
#define TX_FIFO_FULL    0x08

/**
 * drain_rx_fifo - read up to 20 bytes from RX FIFO into buffer
 * @dest_buffer: destination buffer for received data
 * buffer_size : Number of bytes to read
 *
 * Returns: number of bytes copied
 */
int drain_rx_fifo(uint8_t *dest_buffer, int buffer_size) {
    int count = 0;

   while (count < buffer_size) {
        uint32_t reg_val = FIFO_REG;
        uint8_t status = (uint8_t)(reg_val & 0xFF);   // Byte0 = status
        // Stop if RX FIFO is empty
        if (status & RX_FIFO_EMPTY) {
            printf("RX FIFO is EMPTY after reading %d bytes\n", count);
            break;
        }
        // If RX FIFO is full, log it (still safe to read)
        if (status & RX_FIFO_FULL) {
            printf("RX FIFO is FULL while reading, continuing...\n");
        }
        // Extract RX FIFO data from Byte3
        uint8_t data = (uint8_t)((reg_val >> 24) & 0xFF);
        dest_buffer[count++] = data;
    }
    return count;  // number of bytes drained
}
===============================================================================================================
Example Walkthrough
Suppose hardware FIFO has bytes: 0xAA, 0xBB, 0xCC.
First read:
FIFO_REG = 0x00_00_00_AA → status=0x00 (not empty), data=0xAA.
Store 0xAA.
Second read:
FIFO_REG = 0x00_00_00_BB → store 0xBB.
Third read:
FIFO_REG = 0x00_00_00_CC → store 0xCC.
Fourth read:
FIFO_REG = 0x01_00_00_xx → status=0x01 (empty), stop.
Result buffer: [0xAA, 0xBB, 0xCC].
